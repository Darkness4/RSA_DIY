Groupes

C++  :
LYOUSFI Fahd
POIGNANT Mathieu
MAKHLOUF Yassine
DEBUCHY Vivien
OUARI Axel
CHIANESE Maxime


C :
    Rodrigo Lima

VHDL (les b√™tesHHHHHH) quelle belle √©quipe :
Th√©ophile juuuuure MDRRRRR (lui il est foutu aussi)
Louis (lui il est bon)
Alexandre (lui il est foutu)
Abdellah BOUAGOUN (lui c'est notre r√©f√©rent rigaud)
    



JAVA & Kotlin :
    - DALL'AGNOL Eric
    - Bes Emilie
    - Brahmi Wissal
    - Marc NGUYEN
    - Valentin Pollart
    - 

NASM :
    - FROGER youen    

Op√©rations √† impl√©menter
addition grand nombre
soustraction grand nombre
multiplication grand nombre => 12

addition/soustraction modulaire = >14

Multiplication de Montgomery
passage √† la repr√©sentation de Montgomery => 16

RSA complet partie chiffrement et d√©chiffrement => 20 /20

Addition Modulaire
I+J mod N = 

I<N
J< N

si I+J>N : I+J-N    sinon I+J

Multiplication Modulaire

A et B sont √©crits dans la repr√©sentation de Montgomery

Soit N, le modulo de taille 1024 en bits, R est la plus petit puissance de 2 sup√©rieure √† N : soit le min de l'ensemble... 2^1025
Alors V est d√©fini comme l'oppos√© de l'inverse de N mod R
RxR' + Nx(-V) = 1

bonus : R^2 mod N

au+bv = pgcd(a,b) (1 quand a est b sont premiers entre eux)
 au + bv mod b = au =
 
 au = 1 mod b

L'alorithme ci-dessous correspond √† la multiplication de Montgomery des entr√©es I et J

Algorithme MultMtg
1) S = IxJ (multiplication normale dite school book)
2) T = SxV mod R (nombre de taille inf√©rieur √† celle de R)
3) M = S+TxN
4) U = M/R
5) si U>N : U-N    sinon U

Mode brouillon activ√© :

RxR' + Nx(-V) = 1

modulo R on obtient : N(-V) =1 mod R

V=-1/N mod R


    T = S x (-1/N) mod R
    
    M = S + [Sx (-1/N)xN mod R]
    
    M = S + [-S mod R]  avec S = S_1xR + S_0
    M = S_1xR + S_0 + [-S_0]
    M = S_1xR 
    U = M/R = S_1  partie haute de AxB
    
    cons√©quence : 0 < U < 2N
    
    
    Question en suspens : comment trouver la repr√©sentation de Montgomery de A et B ?
    Repr√©sentation classique Mtg
                                A        phi(A)  
                                
                                B        phi(B)  


phi(A) = AxR mod N
phi(B) = BxR mod N

MultMtg(I,J) = IxJxR{-1} mod N  

phi(A) = MultMtg(A,R^2 mod N)

AxR^2xR^{-1} = AxR mod N


R√©ciproquement
A = MultMtg(phi(A),1) = phi(A)xR^{-1} mod N = axRxR^{-1} mod N


Probl√©matique d'impl√©mentations :
    64x64 en C,etc
    Il faut s√©parer partie haute partie basse et g√©rer les additions et regroupement